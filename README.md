# LoongArchLab
simple simulation of von neumann computer for loongarch instruction set


-loongarch.h  
	定义了LoongArch指令集中的不同类型的指令的指令码。指令码根据指令长度进行命名。
	注：这里为了程序可以正常停止，添加了一条停机指令（HALT），它的6位操作码为111111B，在LoongArch指令集中没有使用。


-simple-computer.c  
	在simple-computer.c中，该程序所模拟的计算机中CPU和内存的情况如下：
	CPU：
	o	2个专有寄存器（PC-程序计数器，IR-指令寄存器【注：这里是为了程序方便从而设置了指令寄存器，在LoongArch架构下，是没有专用的指令寄存器的，其中的内容是PC指向内存地址的内容】）
	o	32个通用寄存器（LoongArch架构包含32个通用寄存器，$0-$31）
	内存：
	o	64个字（每个字的长度为32bit，也就是4个字节）
	在simple-computer.c中，首先将第一个参数（args[1]）代表的文件program（要执行的程序）加载到内存中（从地址0开始）并将所有的寄存器初始化（computer_load_init()）。之后根据第二个参数（args[2]）设置PC的值，并启动CPU周期。在每一个CPU周期中，PC所指向的内存地址中的指令被取出（fetch()），之后该指令会被解码（decode()）和执行（execute()）。
	
	在每一个cpu的周期中，cpu都会执行三个基本动作，分别是取指、译码以及执行，这里分别用fetch()、decode()、execute()三个函数表示。

	解码阶段主要任务是对指令进行分析，首先获取指令的操作码（在LoongArch指令集中，操作码可能是前6、7、8、10、12、14、17、22位），根据操作码来判断指令的类型，从而分析得到指令中的各个字段，分析的结果存于INSTRUCTION结构体中。注：这里为了程序可以正常停止，添加了一条停机指令（HALT），它的6位操作码为111111B，在LoongArch指令集中没有使用。

	译码之后的指令在execute()中执行，由于指令操作码长度不一，因此首先判断指令的类型，然后根据指令的操作码进行不同处理。
	
-prog-gen.c
	在该程序中，你首先要构造你想执行的指令，然后将其写入构造好的数组中，最后将数组中的数据全部写入文件中。要想构造可以执行的指令，需要了解LoongArch指令集中的各个指令，最重要的是指令的字段以及这些字段所代表的含义，了解之后你就可以构造指令了。为了使你的计算机可以正常停止，需要添加一条停机指令，这里采用了LoongArch指令集中没有使用的操作码111111B。
